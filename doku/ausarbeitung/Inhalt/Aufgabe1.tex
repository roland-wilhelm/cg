\section{Aufgabe 1}
\label{sec:Aufgabe1}
In dieser Aufgabe soll eine Datei mit Liniensegmenten eingelesen werden und die Liniensegmente anschlie{\ss}end auf Schnittpunkte überprüft werden. Ein Liniensegment besitzt im Gegensatz zu einer Geraden einen Start- und einen Endpunkt. Diese Punkte sind je durch X- und Y-Koordinate definiert. Eine Zeile in der einzulesenden Datei enthält pro Zeile die beiden Koordinaten von Beginn und Ende des Segments.

Der Algorithmus sollte zu Beginn möglichst einfach sein, deshalb wird jede Linie mit jeder anderen Linie auf einen Schnittpunkt getestet. Dadurch entsteht eine abstrakte Laufzeit von O\(n²\).

Um den Algorithmus testen zu können gab es drei verschieden gro{\ss}e Files, eine mit 1000 Segmenten, eine mit 10.000 Segmenten und eine mit 100.000 Segmenten. Die Laufzeit verlängert sich bei verzehnfachung der Linien um ca. das 100 Fache.

\subsection{Einlesen der Daten}
\label{subsec:A1_EinlesenDaten}




\subsection{Ablauf des Algorithmus}
\label{subsec:A1_Algorithmus}
Nachdem die Segmente eingelesen sind, wird die Funktion zur Berechnung der sich schneidenden Linien aufgerufen. Darin enthalten ist die Zeitmessung, diese wird direkt am Funktionsbeginn gestartet und vor der Rückgabe beendet. 

Jede Linie muss immer nur ein Mal mit jeder anderen Linie auf mindestens einen gemeinsamen Punkt getestet werden. Deshalb wird der Test in einer verschachtelten Schleife so realisiert, dass die innere Schleife immer nur nachfolgende Linien abfrägt. Doppelte Abfragen, wie Linie 3 mit Linie 4 und Linie 4 mit Linie 3, werden somit verhindert.

\begin{lstlisting}
	for(unsigned int i = 0; i < m_lines.size(); i++) {
		for(unsigned int j = i+1; j < m_lines.size(); j++) {

			if(m_lines[i]->is_intersection(m_lines[j]) == true) {
				m_intersected_lines_nr++;
			}
		}
	}
\end{lstlisting}

Ergibt der Test auf einen Schnittpunkt ein true, wird eine Membervariable um inkrementiert. Der Algorithmus terminiert wenn das Array, das die Segmente beinhaltet, komplett geprüft wurde. Das Ergebnis ist die Anzahl der Schnittpunkte, die durch die Membervariable festgehalten wird.

\subsection{Test auf Schnittpunkte}
Der Test ob es einen Schnittpunkt gibt, muss in diesem Fall in zwei Abschnitte geteilt werden. Im ersten Abschnitt wird geprüft, ob die Punkte der einen Linie auf der selben Seite der anderen Linie liegen. Das wird mit Hilfe einer Funktion geprüft, die testet ob die übergebenen Punkte gegen den Urzeigersinn verlaufen oder nicht.

Liegen Start- und Endpunkt der anderen Linie, aus sicht beider Strecken, je auf verschiedenen Seiten, gibt es einen Schnittpunkt.

\begin{lstlisting}
else if ( (ccw_max(m_start, m_end, a_line->m_start)*ccw_max(m_start, m_end, a_line->m_end)) < 0
		  && ccw_max(a_line->m_start, a_line->m_end, m_start)*ccw_max(a_line->m_start, a_line->m_end, m_end) < 0 ) {

	//->Schnittpunkt!!
	return true;
}
\end{lstlisting}
 
Zuerst werden die beiden Linien auf Kolinierität geprüft, das würde bedeuten, dass ein Dreieck aus drei der vier Punkte keine Fläche aufspannt.
Falls die Linie ein Punkt ist, wird nun vereinfacht geprüft, ob dieser Punkt auf der anderen Strecke liegt. Ist das der Fall, hat man bereits einen Schnittpunkt gefunden, falls nicht gibt es keinen Schnittpunkt.
\begin{lstlisting}
if ( ccw_max(m_start, m_end, a_line->m_start) == 0 && ccw_max(m_start, m_end, a_line->m_end) == 0) {
	if ( m_start == m_end ) {

		//Punkt liegt auf Linie??
		if( ( m_start > a_line->m_start && m_start < a_line->m_end )
			|| (m_start < a_line->m_start && m_start > a_line->m_end)){
			return true;
		}
		else
			return false;
\end{lstlisting}

Ist die Linie regulär, hat sie also einen vom Startpunkt unterschiedlichen Endpunkt, muss ein \"Uberlappungstest durchgeführt werden.

Hierfür wird der Verktor aus Start- und Endpunkt um 90 Grad und -90 Grad gedreht, sodass zwei zusätzliche Punkte über der Linie entstehen. Nun wird getestet ob die Dreiecke aus Startpunkt, neuem Punkt und einem Punkt der anderen Linie bzw. Endpunkt, zweitem neuem Punkt und dem anderen Punkt der anderen Linie in gleicher Richtung verlaufen. Das bedeutet, Start- und'/oder Endpunkt sind nicht beide auf der gleichen Seite der Strecke - also nicht kolinear.
Ist das der Fall, handelt es sich um eine \"Uberlappung.
\begin{lstlisting}
else { //überlappungstest (line <-> line oder line <-> punkt)
			 //p über m_start - drehung um -90°, q über m_end - drehung um 90° des gegengesetzten Vektor
		Point p(m_end.get_y()-m_start.get_y(), m_end.get_x()-m_start.get_x()),
				  q(m_start.get_y()-m_end.get_y(), m_end.get_x()-m_start.get_x());

		//Start-Punkt auf der Linie (inkl Ränder)
		if( ccw_max(m_start, a_line->m_start, p)*ccw_max(m_end,q,a_line->m_start) >= 0 ){
			return true;
		}
		//End-Punkt auf der Linie (inkl Ränder)
		else if(ccw_max(m_start, a_line->m_end, p)*ccw_max(m_end,q,a_line->m_end) >= 0){
			return true;
		}
		else
			return false;
	}
}
\end{lstlisting}

Sind beide Tests negativ, gibt es keinen Schnittpunkt. Es kann also ein sonst generell gültiger Else-Fall erstellt werden, der false zurück liefert.

\label{subsec:A1_Schnittpunkte}


